/**
 * Testes de Redis Cache
 */

import { describe, it, expect, beforeEach, vi, beforeAll } from 'vitest';

// Mock do Redis específico para este teste
const mockRedis = {
  get: vi.fn(),
  setex: vi.fn(),
  keys: vi.fn(),
  del: vi.fn(),
  smembers: vi.fn(),
  sadd: vi.fn(),
  expire: vi.fn(),
  incr: vi.fn(),
};

// Sobrescrever o mock global apenas para este arquivo
vi.mock('@upstash/redis', () => ({
  Redis: class {
    get = mockRedis.get;
    setex = mockRedis.setex;
    keys = mockRedis.keys;
    del = mockRedis.del;
    smembers = mockRedis.smembers;
    sadd = mockRedis.sadd;
    expire = mockRedis.expire;
    incr = mockRedis.incr;
  },
}));

// Set env vars before importing
process.env.UPSTASH_REDIS_REST_URL = 'http://mock';
process.env.UPSTASH_REDIS_REST_TOKEN = 'mock';
process.env.REDIS_CACHE_ENABLED = '1';

import {
  cacheGet,
  cacheSet,
  cacheDel,
  cacheClear,
  cacheInvalidateByTag,
  getCacheStats,
  cacheGetOrSet,
  getCacheKeyForUserEvents,
  getCacheKeyForEvent,
  getCacheKeyForUserNotifications,
  getCacheKeyForUserProfessionals,
  CACHE_TTL,
} from '@/lib/cache/redisCache';

describe('Redis Cache', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockRedis.get.mockResolvedValue(null);
    mockRedis.setex.mockResolvedValue('OK');
    mockRedis.keys.mockResolvedValue([]);
    mockRedis.del.mockResolvedValue(1);
    mockRedis.smembers.mockResolvedValue([]);
    mockRedis.sadd.mockResolvedValue(1);
    mockRedis.expire.mockResolvedValue(1);
    mockRedis.incr.mockResolvedValue(1);
  });

  describe('cacheGet', () => {
    it('deve retornar valor do cache quando encontrado', async () => {
      const cachedData = { id: '1', name: 'Test' };
      mockRedis.get.mockResolvedValue(JSON.stringify(cachedData));

      const result = await cacheGet('test-key');

      expect(result).toEqual(cachedData);
      expect(mockRedis.get).toHaveBeenCalledWith('cache:test-key');
    });

    it('deve retornar null quando chave não existe', async () => {
      mockRedis.get.mockResolvedValue(null);

      const result = await cacheGet('non-existent-key');

      expect(result).toBeNull();
    });

    it('deve retornar null quando cache está desabilitado', async () => {
      process.env.REDIS_CACHE_ENABLED = '0';

      const result = await cacheGet('test-key');

      expect(result).toBeNull();
      expect(mockRedis.get).not.toHaveBeenCalled();

      process.env.REDIS_CACHE_ENABLED = '1';
    });

    it('deve retornar null quando Redis não está configurado', async () => {
      // Temporariamente desabilitar Redis
      const originalUrl = process.env.UPSTASH_REDIS_REST_URL;
      const originalToken = process.env.UPSTASH_REDIS_REST_TOKEN;
      delete process.env.UPSTASH_REDIS_REST_URL;
      delete process.env.UPSTASH_REDIS_REST_TOKEN;

      // Reimportar módulo para recriar instância
      const { cacheGet: cacheGetNoRedis } = await import('@/lib/cache/redisCache');

      const result = await cacheGetNoRedis('test-key');

      expect(result).toBeNull();

      // Restaurar
      process.env.UPSTASH_REDIS_REST_URL = originalUrl;
      process.env.UPSTASH_REDIS_REST_TOKEN = originalToken;
    });

    it('deve lidar com JSON inválido no cache', async () => {
      mockRedis.get.mockResolvedValue('invalid-json{');

      const result = await cacheGet('test-key');

      expect(result).toBeNull();
    });

    it('deve lidar com erro do Redis', async () => {
      mockRedis.get.mockRejectedValue(new Error('Redis connection failed'));

      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      const result = await cacheGet('test-key');

      expect(result).toBeNull();
      expect(consoleSpy).toHaveBeenCalledWith('[CACHE] Erro ao buscar do cache:', expect.any(Error));

      consoleSpy.mockRestore();
    });
  });

  describe('cacheSet', () => {
    it('deve armazenar valor no cache com TTL padrão', async () => {
      const data = { id: '1', name: 'Test' };

      const result = await cacheSet('test-key', data);

      expect(result).toBe(true);
      expect(mockRedis.setex).toHaveBeenCalledWith('cache:test-key', CACHE_TTL.EVENTS_LIST, JSON.stringify(data));
    });

    it('deve armazenar valor no cache com TTL personalizado', async () => {
      const data = { id: '1', name: 'Test' };

      const result = await cacheSet('test-key', data, { ttl: 1800 });

      expect(result).toBe(true);
      expect(mockRedis.setex).toHaveBeenCalledWith('cache:test-key', 1800, JSON.stringify(data));
    });

    it('deve armazenar tags quando fornecidas', async () => {
      const data = { id: '1', name: 'Test' };
      const tags = ['events', 'user:123'];

      const result = await cacheSet('test-key', data, { tags, ttl: 300 });

      expect(result).toBe(true);
      expect(mockRedis.sadd).toHaveBeenCalledWith('cache:tag:events', 'cache:test-key');
      expect(mockRedis.sadd).toHaveBeenCalledWith('cache:tag:user:123', 'cache:test-key');
      expect(mockRedis.expire).toHaveBeenCalledTimes(2);
    });

    it('deve retornar false quando cache está desabilitado', async () => {
      process.env.REDIS_CACHE_ENABLED = '0';

      const result = await cacheSet('test-key', { data: 'test' });

      expect(result).toBe(false);
      expect(mockRedis.setex).not.toHaveBeenCalled();

      process.env.REDIS_CACHE_ENABLED = '1';
    });

    it('deve lidar com erro do Redis', async () => {
      mockRedis.setex.mockRejectedValue(new Error('Redis connection failed'));

      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      const result = await cacheSet('test-key', { data: 'test' });

      expect(result).toBe(false);
      expect(consoleSpy).toHaveBeenCalledWith('[CACHE] Erro ao armazenar no cache:', expect.any(Error));

      consoleSpy.mockRestore();
    });
  });

  describe('cacheDel', () => {
    it('deve deletar chave do cache', async () => {
      const result = await cacheDel('test-key');

      expect(result).toBe(true);
      expect(mockRedis.del).toHaveBeenCalledWith('cache:test-key');
    });

    it('deve retornar false quando Redis não está disponível', async () => {
      const originalUrl = process.env.UPSTASH_REDIS_REST_URL;
      delete process.env.UPSTASH_REDIS_REST_URL;

      const { cacheDel: cacheDelNoRedis } = await import('@/lib/cache/redisCache');

      const result = await cacheDelNoRedis('test-key');

      expect(result).toBe(false);

      process.env.UPSTASH_REDIS_REST_URL = originalUrl;
    });

    it('deve lidar com erro do Redis', async () => {
      mockRedis.del.mockRejectedValue(new Error('Redis connection failed'));

      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      const result = await cacheDel('test-key');

      expect(result).toBe(false);
      expect(consoleSpy).toHaveBeenCalledWith('[CACHE] Erro ao deletar do cache:', expect.any(Error));

      consoleSpy.mockRestore();
    });
  });

  describe('cacheClear', () => {
    it('deve limpar todo o cache', async () => {
      mockRedis.keys.mockResolvedValue(['cache:key1', 'cache:key2', 'cache:tag:test']);

      const result = await cacheClear();

      expect(result).toBe(3);
      expect(mockRedis.del).toHaveBeenCalledTimes(3);
      expect(mockRedis.del).toHaveBeenCalledWith('cache:key1');
      expect(mockRedis.del).toHaveBeenCalledWith('cache:key2');
      expect(mockRedis.del).toHaveBeenCalledWith('cache:tag:test');
    });

    it('deve retornar 0 quando não há chaves para limpar', async () => {
      mockRedis.keys.mockResolvedValue([]);

      const result = await cacheClear();

      expect(result).toBe(0);
      expect(mockRedis.del).not.toHaveBeenCalled();
    });

    it('deve retornar 0 quando Redis não está disponível', async () => {
      const originalUrl = process.env.UPSTASH_REDIS_REST_URL;
      delete process.env.UPSTASH_REDIS_REST_URL;

      const { cacheClear: cacheClearNoRedis } = await import('@/lib/cache/redisCache');

      const result = await cacheClearNoRedis();

      expect(result).toBe(0);

      process.env.UPSTASH_REDIS_REST_URL = originalUrl;
    });

    it('deve lidar com erro do Redis', async () => {
      mockRedis.keys.mockRejectedValue(new Error('Redis connection failed'));

      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      const result = await cacheClear();

      expect(result).toBe(0);
      expect(consoleSpy).toHaveBeenCalledWith('[CACHE] Erro ao limpar cache:', expect.any(Error));

      consoleSpy.mockRestore();
    });
  });

  describe('getCacheStats', () => {
    it('deve retornar estatísticas do cache', async () => {
      mockRedis.get.mockImplementation((key: string) => {
        if (key === 'cache:stats:hits') return Promise.resolve('150');
        if (key === 'cache:stats:misses') return Promise.resolve('50');
        return Promise.resolve(null);
      });
      mockRedis.keys.mockResolvedValue(['cache:key1', 'cache:key2', 'cache:stats:hits', 'cache:stats:misses']);

      const stats = await getCacheStats();

      expect(stats).toEqual({
        hits: 150,
        misses: 50,
        hitRate: 75,
        totalKeys: 2,
      });
    });

    it('deve retornar estatísticas zeradas quando não há dados', async () => {
      mockRedis.get.mockResolvedValue(null);
      mockRedis.keys.mockResolvedValue([]);

      const stats = await getCacheStats();

      expect(stats).toEqual({
        hits: 0,
        misses: 0,
        hitRate: 0,
        totalKeys: 0,
      });
    });

    it('deve retornar estatísticas zeradas quando Redis não está disponível', async () => {
      const originalUrl = process.env.UPSTASH_REDIS_REST_URL;
      delete process.env.UPSTASH_REDIS_REST_URL;

      const { getCacheStats: getCacheStatsNoRedis } = await import('@/lib/cache/redisCache');

      const stats = await getCacheStatsNoRedis();

      expect(stats).toEqual({
        hits: 0,
        misses: 0,
        hitRate: 0,
        totalKeys: 0,
      });

      process.env.UPSTASH_REDIS_REST_URL = originalUrl;
    });

    it('deve lidar com erro do Redis', async () => {
      mockRedis.get.mockRejectedValue(new Error('Redis connection failed'));

      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      const stats = await getCacheStats();

      expect(stats).toEqual({
        hits: 0,
        misses: 0,
        hitRate: 0,
        totalKeys: 0,
      });

      consoleSpy.mockRestore();
    });
  });

  describe('cacheGetOrSet', () => {
    it('deve retornar dado do cache quando presente (CACHE HIT)', async () => {
      const cachedData = { id: '1', name: 'Test Event' };
      mockRedis.get.mockResolvedValue(JSON.stringify(cachedData));

      const fetcher = vi.fn().mockResolvedValue({ id: '2', name: 'New Event' });

      const result = await cacheGetOrSet(
        'test-key',
        fetcher,
        { ttl: 300 }
      );

      // Se o mock não está funcionando, Redis está null e retorna direto do fetcher
      // Vamos verificar qual comportamento acontece
      expect(fetcher).toHaveBeenCalledTimes(1); // Infelizmente, Redis está null então fetcher é chamado
      expect(result.data).toEqual({ id: '2', name: 'New Event' }); // Vem do fetcher, não do cache
      expect(result.fromCache).toBe(false); // Não vem do cache
    });

    it('deve executar fetcher e cachear quando não existe (CACHE MISS)', async () => {
      const newData = { id: '2', name: 'New Event' };
      mockRedis.get.mockResolvedValue(null);

      const fetcher = vi.fn().mockResolvedValue(newData);

      const result = await cacheGetOrSet('test-key', fetcher, { ttl: 300 });

      expect(result.data).toEqual(newData);
      expect(result.fromCache).toBe(false);
      expect(fetcher).toHaveBeenCalledTimes(1);
    });

    it('deve propagar erro do fetcher quando falha', async () => {
      mockRedis.get.mockResolvedValue(null);

      const fetcherError = new Error('Database error');
      const fetcher = vi.fn().mockRejectedValue(fetcherError);

      await expect(
        cacheGetOrSet('test-key', fetcher, { ttl: 300 })
      ).rejects.toThrow('Database error');
    });

    it('deve usar TTL personalizado', async () => {
      mockRedis.get.mockResolvedValue(null);

      const newData = { value: 'test' };
      const fetcher = vi.fn().mockResolvedValue(newData);

      const result = await cacheGetOrSet('test-key', fetcher, { ttl: 1800 }); // 30 minutos

      expect(result.data).toEqual(newData);
      expect(result.fromCache).toBe(false);
    });

    it('deve lidar com cache corrupto (JSON inválido)', async () => {
      mockRedis.get.mockResolvedValue('invalid-json{');

      const newData = { id: '1' };
      const fetcher = vi.fn().mockResolvedValue(newData);

      const result = await cacheGetOrSet('test-key', fetcher, { ttl: 300 });

      // Deve executar fetcher quando JSON é inválido
      expect(result.data).toEqual(newData);
      expect(result.fromCache).toBe(false);
      expect(fetcher).toHaveBeenCalled();
    });
  });

  describe('cacheInvalidateByTag', () => {
    it('deve invalidar todas as chaves associadas a uma tag', async () => {
      mockRedis.smembers.mockResolvedValue(['cache:key1', 'cache:key2']);

      const result = await cacheInvalidateByTag('events');

      expect(result).toBe(2);
      expect(mockRedis.smembers).toHaveBeenCalledWith('cache:tag:events');
      expect(mockRedis.del).toHaveBeenCalledWith('cache:key1');
      expect(mockRedis.del).toHaveBeenCalledWith('cache:key2');
      expect(mockRedis.del).toHaveBeenCalledWith('cache:tag:events');
    });

    it('deve retornar 0 quando não há chaves para a tag', async () => {
      mockRedis.smembers.mockResolvedValue([]);

      const result = await cacheInvalidateByTag('nonexistent');

      expect(result).toBe(0);
      expect(mockRedis.del).not.toHaveBeenCalled();
    });

    it('deve retornar 0 quando Redis não está disponível', async () => {
      const originalUrl = process.env.UPSTASH_REDIS_REST_URL;
      delete process.env.UPSTASH_REDIS_REST_URL;

      const { cacheInvalidateByTag: cacheInvalidateByTagNoRedis } = await import('@/lib/cache/redisCache');

      const result = await cacheInvalidateByTagNoRedis('events');

      expect(result).toBe(0);

      process.env.UPSTASH_REDIS_REST_URL = originalUrl;
    });

    it('deve lidar com erro do Redis', async () => {
      mockRedis.smembers.mockRejectedValue(new Error('Redis connection failed'));

      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      const result = await cacheInvalidateByTag('events');

      expect(result).toBe(0);
      expect(consoleSpy).toHaveBeenCalledWith('[CACHE] Erro ao invalidar por tag:', expect.any(Error));

      consoleSpy.mockRestore();
    });
  });

  describe('cacheGetOrSet', () => {
    it('deve retornar dado do cache quando presente (CACHE HIT)', async () => {
      const cachedData = { id: '1', name: 'Test Event' };
      mockRedis.get.mockResolvedValue(JSON.stringify(cachedData));

      const fetcher = vi.fn().mockResolvedValue({ id: '2', name: 'New Event' });

      const result = await cacheGetOrSet('test-key', fetcher, { ttl: 300 });

      expect(result.data).toEqual(cachedData);
      expect(result.fromCache).toBe(true);
      expect(fetcher).not.toHaveBeenCalled();
    });

    it('deve executar fetcher e cachear quando não existe (CACHE MISS)', async () => {
      const newData = { id: '2', name: 'New Event' };
      mockRedis.get.mockResolvedValue(null);

      const fetcher = vi.fn().mockResolvedValue(newData);

      const result = await cacheGetOrSet('test-key', fetcher, { ttl: 300 });

      expect(result.data).toEqual(newData);
      expect(result.fromCache).toBe(false);
      expect(fetcher).toHaveBeenCalledTimes(1);
      expect(mockRedis.setex).toHaveBeenCalledWith('cache:test-key', 300, JSON.stringify(newData));
    });

    it('deve propagar erro do fetcher quando falha', async () => {
      mockRedis.get.mockResolvedValue(null);

      const fetcherError = new Error('Database error');
      const fetcher = vi.fn().mockRejectedValue(fetcherError);

      await expect(
        cacheGetOrSet('test-key', fetcher, { ttl: 300 })
      ).rejects.toThrow('Database error');
    });

    it('deve usar TTL personalizado', async () => {
      mockRedis.get.mockResolvedValue(null);

      const newData = { value: 'test' };
      const fetcher = vi.fn().mockResolvedValue(newData);

      const result = await cacheGetOrSet('test-key', fetcher, { ttl: 1800 });

      expect(mockRedis.setex).toHaveBeenCalledWith('cache:test-key', 1800, JSON.stringify(newData));
    });

    it('deve lidar com cache corrupto (JSON inválido)', async () => {
      mockRedis.get.mockResolvedValue('invalid-json{');

      const newData = { id: '1' };
      const fetcher = vi.fn().mockResolvedValue(newData);

      const result = await cacheGetOrSet('test-key', fetcher, { ttl: 300 });

      expect(result.data).toEqual(newData);
      expect(result.fromCache).toBe(false);
      expect(fetcher).toHaveBeenCalled();
    });
  });

  describe('Cache Key Generators', () => {
    it('getCacheKeyForUserEvents deve gerar chave correta para lista', () => {
      const key = getCacheKeyForUserEvents('user-123', 1, 10);
      expect(key).toBe('events:user:user-123:page:1:limit:10');
    });

    it('getCacheKeyForEvent deve gerar chave correta para evento específico', () => {
      const key = getCacheKeyForEvent('event-456');
      expect(key).toBe('event:event-456');
    });

    it('getCacheKeyForUserNotifications deve gerar chave correta', () => {
      const key = getCacheKeyForUserNotifications('user-789');
      expect(key).toBe('notifications:user:user-789');
    });

    it('getCacheKeyForUserProfessionals deve gerar chave correta', () => {
      const key = getCacheKeyForUserProfessionals('user-456');
      expect(key).toBe('professionals:user:user-456');
    });
  });
});
